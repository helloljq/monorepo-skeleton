# =============================================================================
# CD Pipeline - 持续部署 (完整栈 Docker Compose)
# =============================================================================
# 此流水线负责构建 Docker 镜像并通过 SSH 部署到服务器
# 使用 deploy/staging/ 和 deploy/prod/ 的 docker-compose.yml（包含数据库容器）
#
# 触发条件:
#   - release/* 分支: 部署到 staging 环境
#   - main 分支: 部署到 production 环境（需手动批准）
#
# ============================================================================
# 必需的 GitHub Secrets
# ============================================================================
#
# 镜像仓库:
#   - DOCKER_REGISTRY: 镜像仓库地址 (如 registry.cn-hangzhou.aliyuncs.com)
#   - DOCKER_NAMESPACE: 镜像命名空间 (如 {{NAME}}ht)
#   - DOCKER_USERNAME: 仓库用户名
#   - DOCKER_PASSWORD: 仓库密码
#
# Staging 服务器:
#   - STAGING_SERVER_HOST: 服务器 IP 或域名
#   - STAGING_SERVER_USER: SSH 用户名
#   - STAGING_SERVER_SSH_KEY: SSH 私钥
#   - STAGING_POSTGRES_PASSWORD: PostgreSQL 密码
#   - STAGING_REDIS_PASSWORD: Redis 密码
#   - STAGING_JWT_ACCESS_SECRET: JWT 密钥 (32+ 字符)
#   - STAGING_JWT_REFRESH_SECRET: JWT 刷新密钥
#   - STAGING_CORS_ORIGINS: CORS 白名单 (逗号分隔)
#
# Production 服务器:
#   - PROD_SERVER_HOST
#   - PROD_SERVER_USER
#   - PROD_SERVER_SSH_KEY
#   - PROD_POSTGRES_PASSWORD
#   - PROD_REDIS_PASSWORD
#   - PROD_JWT_ACCESS_SECRET
#   - PROD_JWT_REFRESH_SECRET
#   - PROD_CORS_ORIGINS
#
# 共享:
#   - CONFIG_ENCRYPTION_KEY: 配置加密密钥
#
# =============================================================================

name: CD

on:
  push:
    branches:
      - main
      - 'release/**'
  workflow_dispatch:
    inputs:
      environment:
        description: '部署环境'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: false

env:
  DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
  DOCKER_NAMESPACE: ${{ secrets.DOCKER_NAMESPACE }}

jobs:
  # ===========================================================================
  # 确定部署环境 + 变更检测
  # ===========================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      # 变更检测输出（workflow_dispatch 时强制全部为 true）
      server_changed: ${{ github.event_name == 'workflow_dispatch' || steps.changes.outputs.server == 'true' }}
      admin_changed: ${{ github.event_name == 'workflow_dispatch' || steps.changes.outputs.admin == 'true' }}
      www_changed: ${{ github.event_name == 'workflow_dispatch' || steps.changes.outputs.www == 'true' }}
      any_changed: ${{ github.event_name == 'workflow_dispatch' || steps.changes.outputs.server == 'true' || steps.changes.outputs.admin == 'true' || steps.changes.outputs.www == 'true' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            server:
              - 'apps/server/**'
              - 'packages/shared-types/**'
              - 'packages/shared-utils/**'
              - '.dockerignore'
              - 'turbo.json'
              - 'tooling/**'
              - 'pnpm-lock.yaml'
            admin:
              - 'apps/admin-web/**'
              - 'packages/shared-types/**'
              - 'packages/shared-utils/**'
              - '.dockerignore'
              - 'turbo.json'
              - 'tooling/**'
              - 'pnpm-lock.yaml'
            www:
              - 'apps/www-web/**'
              - 'packages/shared-types/**'
              - 'packages/shared-utils/**'
              - '.dockerignore'
              - 'turbo.json'
              - 'tooling/**'
              - 'pnpm-lock.yaml'

      - name: Set deployment environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "image_tag=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "### 变更检测结果" >> $GITHUB_STEP_SUMMARY
          echo "| 应用 | 是否变更 |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| server | ${{ steps.changes.outputs.server }} |" >> $GITHUB_STEP_SUMMARY
          echo "| admin-web | ${{ steps.changes.outputs.admin }} |" >> $GITHUB_STEP_SUMMARY
          echo "| www-web | ${{ steps.changes.outputs.www }} |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # 构建 Docker 镜像 - 按需构建
  # ===========================================================================
  build-server:
    name: Build Server
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      needs.prepare.outputs.should_deploy == 'true' &&
      (needs.prepare.outputs.server_changed == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Registry
        run: |
          docker logout "${{ env.DOCKER_REGISTRY }}" 2>/dev/null || true
          for i in 1 2 3; do
            echo "Docker login attempt $i..."
            if echo "${{ secrets.DOCKER_PASSWORD }}" | docker login "${{ env.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin; then
              echo "✅ Docker login successful"
              exit 0
            fi
            echo "❌ Docker login failed, retrying in 5s..."
            sleep 5
          done
          echo "❌ Docker login failed after 3 attempts"
          exit 1

      - name: Build and push server
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/server/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/server:${{ needs.prepare.outputs.image_tag }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/server:${{ needs.prepare.outputs.environment }}-latest
          cache-from: type=gha,scope=server
          cache-to: type=gha,mode=max,scope=server

  build-admin:
    name: Build Admin Web
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      needs.prepare.outputs.should_deploy == 'true' &&
      (needs.prepare.outputs.admin_changed == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Registry
        run: |
          docker logout "${{ env.DOCKER_REGISTRY }}" 2>/dev/null || true
          for i in 1 2 3; do
            echo "Docker login attempt $i..."
            if echo "${{ secrets.DOCKER_PASSWORD }}" | docker login "${{ env.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin; then
              echo "✅ Docker login successful"
              exit 0
            fi
            echo "❌ Docker login failed, retrying in 5s..."
            sleep 5
          done
          echo "❌ Docker login failed after 3 attempts"
          exit 1

      - name: Set API URL
        id: api-url
        run: |
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "api_url=https://api.{{DOMAIN}}" >> $GITHUB_OUTPUT
          else
            echo "api_url=https://api-staging.{{DOMAIN}}" >> $GITHUB_OUTPUT
          fi

      - name: Build and push admin-web
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/admin-web/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/admin-web:${{ needs.prepare.outputs.image_tag }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/admin-web:${{ needs.prepare.outputs.environment }}-latest
          build-args: |
            VITE_API_BASE_URL=${{ steps.api-url.outputs.api_url }}
          cache-from: type=gha,scope=admin-web
          cache-to: type=gha,mode=max,scope=admin-web

  build-www:
    name: Build WWW Web
    runs-on: ubuntu-latest
    needs: prepare
    if: |
      needs.prepare.outputs.should_deploy == 'true' &&
      (needs.prepare.outputs.www_changed == 'true' || github.event_name == 'workflow_dispatch')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Registry
        run: |
          docker logout "${{ env.DOCKER_REGISTRY }}" 2>/dev/null || true
          for i in 1 2 3; do
            echo "Docker login attempt $i..."
            if echo "${{ secrets.DOCKER_PASSWORD }}" | docker login "${{ env.DOCKER_REGISTRY }}" -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin; then
              echo "✅ Docker login successful"
              exit 0
            fi
            echo "❌ Docker login failed, retrying in 5s..."
            sleep 5
          done
          echo "❌ Docker login failed after 3 attempts"
          exit 1

      - name: Set API URL
        id: api-url
        run: |
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "api_url=https://api.{{DOMAIN}}" >> $GITHUB_OUTPUT
          else
            echo "api_url=https://api-staging.{{DOMAIN}}" >> $GITHUB_OUTPUT
          fi

      - name: Build and push www-web
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/www-web/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/www-web:${{ needs.prepare.outputs.image_tag }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_NAMESPACE }}/www-web:${{ needs.prepare.outputs.environment }}-latest
          build-args: |
            VITE_API_BASE_URL=${{ steps.api-url.outputs.api_url }}
          cache-from: type=gha,scope=www-web
          cache-to: type=gha,mode=max,scope=www-web

  # ===========================================================================
  # 部署到 Staging 环境
  # ===========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare, build-server, build-admin, build-www]
    # 使用 always() 因为某些 build job 可能被跳过
    if: |
      always() &&
      needs.prepare.outputs.environment == 'staging' &&
      needs.prepare.result == 'success' &&
      (needs.build-server.result == 'success' || needs.build-server.result == 'skipped') &&
      (needs.build-admin.result == 'success' || needs.build-admin.result == 'skipped') &&
      (needs.build-www.result == 'success' || needs.build-www.result == 'skipped')
    environment:
      name: staging
      url: https://www-staging.{{DOMAIN}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.STAGING_SERVER_HOST }}
          username: ${{ secrets.STAGING_SERVER_USER }}
          key: ${{ secrets.STAGING_SERVER_SSH_KEY }}
          source: "deploy/staging/docker-compose.yml"
          target: "/opt/{{NAME}}/staging"
          strip_components: 2

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          DOCKER_NAMESPACE: ${{ secrets.DOCKER_NAMESPACE }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          SERVER_CHANGED: ${{ needs.prepare.outputs.server_changed }}
          ADMIN_CHANGED: ${{ needs.prepare.outputs.admin_changed }}
          WWW_CHANGED: ${{ needs.prepare.outputs.www_changed }}
        with:
          host: ${{ secrets.STAGING_SERVER_HOST }}
          username: ${{ secrets.STAGING_SERVER_USER }}
          key: ${{ secrets.STAGING_SERVER_SSH_KEY }}
          envs: IMAGE_TAG,DOCKER_REGISTRY,DOCKER_NAMESPACE,DOCKER_USERNAME,DOCKER_PASSWORD,SERVER_CHANGED,ADMIN_CHANGED,WWW_CHANGED
          script: |
            set -e

            DEPLOY_DIR="/opt/{{NAME}}/staging"
            BACKUP_DIR="$DEPLOY_DIR/backup"
            cd "$DEPLOY_DIR"
            mkdir -p "$BACKUP_DIR"

            # 登录 Docker Registry（带重试）
            docker logout "$DOCKER_REGISTRY" 2>/dev/null || true

            for i in 1 2 3; do
              echo "Docker login attempt $i..."
              if echo "$DOCKER_PASSWORD" | docker login "$DOCKER_REGISTRY" -u "$DOCKER_USERNAME" --password-stdin; then
                echo "✅ Docker login successful"
                break
              fi
              if [ $i -eq 3 ]; then
                echo "❌ Docker login failed after 3 attempts"
                exit 1
              fi
              echo "❌ Docker login failed, retrying in 5s..."
              sleep 5
            done

            # 检查 .env 是否存在
            if [ ! -f .env ]; then
              echo "❌ .env 文件不存在，请先在服务器上配置"
              exit 1
            fi

            # 更新变更服务的 IMAGE_TAG（每个服务独立的 tag）
            update_image_tag() {
              local var_name=$1
              local new_tag=$2
              if grep -q "^${var_name}=" .env; then
                sed -i "s/^${var_name}=.*/${var_name}=${new_tag}/" .env
              else
                echo "${var_name}=${new_tag}" >> .env
              fi
              echo "  ${var_name}=${new_tag}"
            }

            echo "📝 更新镜像版本..."
            SERVICES_TO_UPDATE=""
            if [ "$SERVER_CHANGED" == "true" ]; then
              update_image_tag "SERVER_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }server"
            fi
            if [ "$ADMIN_CHANGED" == "true" ]; then
              update_image_tag "ADMIN_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }admin-web"
            fi
            if [ "$WWW_CHANGED" == "true" ]; then
              update_image_tag "WWW_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }www-web"
            fi

            if [ -n "$SERVICES_TO_UPDATE" ]; then
              echo "📦 需要更新的服务: $SERVICES_TO_UPDATE"

              # 拉取变更的镜像
              echo "📥 拉取新镜像..."
              docker compose pull $SERVICES_TO_UPDATE

              # 停止占用端口的旧容器（兼容旧部署方式）
              echo "🧹 清理占用端口的旧容器..."
              for port in 8110 3110 3210; do
                container_id=$(docker ps -q --filter "publish=$port")
                if [ -n "$container_id" ]; then
                  echo "停止占用端口 $port 的容器: $container_id"
                  docker stop $container_id || true
                  docker rm $container_id || true
                fi
              done

              # 启动/更新变更的服务
              echo "🚀 部署版本: $IMAGE_TAG"
              docker compose up -d $SERVICES_TO_UPDATE
            else
              echo "⚠️ 没有服务需要更新镜像"
            fi

            # 确保所有服务都在运行（修复之前未启动的服务）
            echo "🔍 检查所有服务状态..."
            docker compose up -d

            # 如果 server 有更新，等待健康并执行迁移
            if [ "$SERVER_CHANGED" == "true" ]; then
              echo "⏳ 等待服务健康..."
              SERVER_HEALTHY=false
              for i in {1..30}; do
                if docker compose exec -T server wget -q --spider http://localhost:8100/health 2>/dev/null; then
                  echo "✅ Server 健康"
                  SERVER_HEALTHY=true
                  break
                fi
                echo "等待中... ($i/30)"
                sleep 2
              done

              if [ "$SERVER_HEALTHY" != "true" ]; then
                echo "❌ Server 健康检查失败，中止部署"
                exit 1
              fi

              echo "📊 执行数据库迁移..."
              docker compose exec -T server pnpm prisma migrate deploy

              echo "🌱 执行种子数据..."
              docker compose exec -T server pnpm prisma db seed || true
            fi

            # 清理旧镜像
            docker image prune -f

            echo "✅ Staging 部署成功！版本: $IMAGE_TAG (更新: $SERVICES_TO_UPDATE)"

      - name: Health check
        if: needs.prepare.outputs.any_changed == 'true'
        run: |
          for i in {1..12}; do
            if curl -sf "https://api-staging.{{DOMAIN}}/health" > /dev/null; then
              echo "✅ 健康检查通过"
              exit 0
            fi
            echo "等待服务就绪... ($i/12)"
            sleep 5
          done
          echo "❌ 健康检查失败"
          exit 1

  # ===========================================================================
  # 部署到 Production 环境
  # ===========================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare, build-server, build-admin, build-www]
    if: |
      always() &&
      needs.prepare.outputs.environment == 'production' &&
      needs.prepare.result == 'success' &&
      (needs.build-server.result == 'success' || needs.build-server.result == 'skipped') &&
      (needs.build-admin.result == 'success' || needs.build-admin.result == 'skipped') &&
      (needs.build-www.result == 'success' || needs.build-www.result == 'skipped')
    environment:
      name: production
      url: https://www.{{DOMAIN}}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SERVER_HOST }}
          username: ${{ secrets.PROD_SERVER_USER }}
          key: ${{ secrets.PROD_SERVER_SSH_KEY }}
          source: "deploy/prod/docker-compose.yml"
          target: "/opt/{{NAME}}/prod"
          strip_components: 2

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
          DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}
          DOCKER_NAMESPACE: ${{ secrets.DOCKER_NAMESPACE }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          SERVER_CHANGED: ${{ needs.prepare.outputs.server_changed }}
          ADMIN_CHANGED: ${{ needs.prepare.outputs.admin_changed }}
          WWW_CHANGED: ${{ needs.prepare.outputs.www_changed }}
        with:
          host: ${{ secrets.PROD_SERVER_HOST }}
          username: ${{ secrets.PROD_SERVER_USER }}
          key: ${{ secrets.PROD_SERVER_SSH_KEY }}
          envs: IMAGE_TAG,DOCKER_REGISTRY,DOCKER_NAMESPACE,DOCKER_USERNAME,DOCKER_PASSWORD,SERVER_CHANGED,ADMIN_CHANGED,WWW_CHANGED
          script: |
            set -e

            DEPLOY_DIR="/opt/{{NAME}}/prod"
            BACKUP_DIR="$DEPLOY_DIR/backup"
            cd "$DEPLOY_DIR"
            mkdir -p "$BACKUP_DIR"

            # 登录 Docker Registry（带重试）
            docker logout "$DOCKER_REGISTRY" 2>/dev/null || true

            for i in 1 2 3; do
              echo "Docker login attempt $i..."
              if echo "$DOCKER_PASSWORD" | docker login "$DOCKER_REGISTRY" -u "$DOCKER_USERNAME" --password-stdin; then
                echo "✅ Docker login successful"
                break
              fi
              if [ $i -eq 3 ]; then
                echo "❌ Docker login failed after 3 attempts"
                exit 1
              fi
              echo "❌ Docker login failed, retrying in 5s..."
              sleep 5
            done

            # 检查 .env 是否存在
            if [ ! -f .env ]; then
              echo "❌ .env 文件不存在，请先在服务器上配置"
              exit 1
            fi

            # 更新变更服务的 IMAGE_TAG（每个服务独立的 tag）
            update_image_tag() {
              local var_name=$1
              local new_tag=$2
              if grep -q "^${var_name}=" .env; then
                sed -i "s/^${var_name}=.*/${var_name}=${new_tag}/" .env
              else
                echo "${var_name}=${new_tag}" >> .env
              fi
              echo "  ${var_name}=${new_tag}"
            }

            echo "📝 更新镜像版本..."
            SERVICES_TO_UPDATE=""
            if [ "$SERVER_CHANGED" == "true" ]; then
              update_image_tag "SERVER_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }server"
            fi
            if [ "$ADMIN_CHANGED" == "true" ]; then
              update_image_tag "ADMIN_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }admin-web"
            fi
            if [ "$WWW_CHANGED" == "true" ]; then
              update_image_tag "WWW_IMAGE_TAG" "$IMAGE_TAG"
              SERVICES_TO_UPDATE="${SERVICES_TO_UPDATE:+$SERVICES_TO_UPDATE }www-web"
            fi

            if [ -n "$SERVICES_TO_UPDATE" ]; then
              echo "📦 需要更新的服务: $SERVICES_TO_UPDATE"

              # 拉取变更的镜像
              echo "📥 拉取新镜像..."
              docker compose pull $SERVICES_TO_UPDATE

              # 停止占用端口的旧容器（兼容旧部署方式）
              echo "🧹 清理占用端口的旧容器..."
              for port in 8120 3120 3220; do
                container_id=$(docker ps -q --filter "publish=$port")
                if [ -n "$container_id" ]; then
                  echo "停止占用端口 $port 的容器: $container_id"
                  docker stop $container_id || true
                  docker rm $container_id || true
                fi
              done

              # 启动/更新变更的服务
              echo "🚀 部署版本: $IMAGE_TAG"
              docker compose up -d $SERVICES_TO_UPDATE
            else
              echo "⚠️ 没有服务需要更新镜像"
            fi

            # 确保所有服务都在运行（修复之前未启动的服务）
            echo "🔍 检查所有服务状态..."
            docker compose up -d

            # 如果 server 有更新，等待健康并执行迁移
            if [ "$SERVER_CHANGED" == "true" ]; then
              echo "⏳ 等待服务健康..."
              SERVER_HEALTHY=false
              for i in {1..30}; do
                if docker compose exec -T server wget -q --spider http://localhost:8100/health 2>/dev/null; then
                  echo "✅ Server 健康"
                  SERVER_HEALTHY=true
                  break
                fi
                echo "等待中... ($i/30)"
                sleep 2
              done

              if [ "$SERVER_HEALTHY" != "true" ]; then
                echo "❌ Server 健康检查失败，中止部署"
                exit 1
              fi

              echo "📊 执行数据库迁移..."
              docker compose exec -T server pnpm prisma migrate deploy

              echo "🌱 执行种子数据..."
              docker compose exec -T server pnpm prisma db seed || true
            fi

            # 清理旧镜像
            docker image prune -f

            echo "✅ Production 部署成功！版本: $IMAGE_TAG (更新: $SERVICES_TO_UPDATE)"

      - name: Health check
        if: needs.prepare.outputs.any_changed == 'true'
        run: |
          for i in {1..12}; do
            if curl -sf "https://api.{{DOMAIN}}/health" > /dev/null; then
              echo "✅ 健康检查通过"
              exit 0
            fi
            echo "等待服务就绪... ($i/12)"
            sleep 5
          done
          echo "❌ 健康检查失败"
          exit 1
